---
tag: 
  - C语言
---

# 数组与指针

## 数组

- 数组由数据类型相同的一系列元素组成。

```c
// 一些数组声明
int main(void) {
    float candy[365]    // 内含365个float类型的元素的数组
    char code[12]       // 内含12个char类型元素的数组
    int states[50]      // 内含50个int类型元素的数组
}
```

使用数组下标(索引)表示数组中的各元素，数组编号从 0 开始。

### 初始化数组

```c
int main(void) {
    int powers[8] = {1,2,4,6,8,16,32,64}    // 从ANSI C开始支持这种初始化
}

// 推荐使用符号常量来表示数组大小,方便于管理
#define NUM 8

int main(void) {
    int powers[NUM] = {1,2,4,6,8,16,32,64}
}
```

- 使用 const 声明只读数组，不能把新值写入数组。

```c
#define MONTH 12

int main(void) {
    const int days[MONTH] = {31,28,31,30,31,30,31,31,30,31,30,31}
}
```

- 当我们使用数组前必须先初始化它。与普通变量类似，在使用数组元素之前，必须先给它们赋初值。编译器使用的值是内存相应位置上的现有值。**注意存储类别的区别，这里使用的是自动存储类别。不同的存储类别有不同的属性，不能把此知识点推广到其他存储类别上。使用其他的存储类别时，如果在声明时未初始化，编译器会自动把它们的值设置为 0。**

- 如果不初始化数组，数组元素和未初始化的普通变量一样，其中存储的都是垃圾值；但是，如果部分初始化数组，剩余的元素就会被初始化为 0。

```c
#include<stdio.h>
#define NUM 8

int main(void) {
    int powers[NUM] = {1,2,4,6};
    int i;

    for(i = 0,i < NUM,i++) {
        printf("%d",powers[i]);
    }

    return 0;
}

// 输出结果
1,2,4,6,0,0,0,0
```

- 如果初始化列表项多于数组元素的个数，编译报错

```c
#define NUM 8
int main(void) {
    int powers[NUM] = {1,2,3,4,5,6,7,8,9,10};
}
```

- 省略方括号中的数字，让编译器自动匹配数组大小和初始化列表中的项数

```c
int main(void) {
    int powers[] = {1,2,3,4,5,6,7,8,9,10};
}
```

- 指定初始化器

```c
int arr[6] = {[5] = 212,[1] = 20,21,22}

// 初始化内部结果
int arr[6] = {0,20,21,22,0,212}
```

> 指定初始化器的两个重要特性： 1.如果指定初始化器后面有更多的值，那么后面这些值将被用于初始化指定元素后面的元素。 2.如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。

- 给数组元素赋值

  - 声明数组后，可以借助数组下标（或索引）给数组元素复制。
  - **C 不允许把数组作为一个单元赋给另一个数组，除初始化以外也不允许使用花括号列表的形式赋值。**

- 数组边界
  - 使用数组时，要防止数组下标超出边界。也就是说，必须确保下标是有效的值。使用数组时，要防止数组下标超出边界。也就是说，必须确保下标是有效的值
  - 使用越界的数组下标会导致程序改变其他变量的值。不同的编译器运行该程序的结果可能不同，有些会导致程序异常中止。

### 多维数组

- 初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保证初始化的数值个数正确，初始化的效果与上面相同。但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值。后面没有值初始化的元素被统一初始化为 0。

```c
int sq[2][3] = {{5,6},{7,8}};

// 初始化后
[
    [5,6,0],
    [7,8,0]
]
int sq[2][3] = {5,6,7,8}
// 初始化后
[
    [5,6,7],
    [8,0,0]
]

```

### 指针和数组

- 指针提供一种以符号形式使用地址的方法。因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。

- 在我们的系统中，地址按字节编址，**short 类型占用 2 字节，double 类型占用 8 字节。** 在 C 中，指针加 1 指的是增加一个存储单元。对数组而言，这意味着加 1 后的地址是下一个元素的地址，而不是下一个字节的地址。

- 指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。许多计算机（包括 PC 喝 Macintosh）都是按字节编址，意思是内存中的每个字节都按顺序编号。这里，一个较大对象的地址（如 double 类型的变量）通常是该对象第一个字节的地址。
- 在指针前面使用\*运算符可以得到该指针所指向对象的值。
- 指针加 1，指针的值递增它所指向类型的大小（以字节为单位）。

```c
dates + 2 == &dates[2]
*(dates + 2) == dates[2]
```

### 函数、数组和指针

- 数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针。

```c
#include<stdio.h>
#define SIZE 10
int sum(int ar[],int n)
int main(void) {
    int marbles[SIZE] = {20,10,5,39,4,16,19,26,31,20};
    long answer;

    answer = sum(marbles,SIZE);
    printf("The total number of marbles is %ld.\n",answer);
    printf("The size of marbles is %zd bytes.\n", sizeof marbles);


    return 0;
}

int sum(int ar[],int n) {
    int i;
    int total = 0;

    for(i = 0; i < n; i++) {
        total += ar[i];
    }

    printf("The size of ar is %zd bytes.\n",sizeof &ar);

    return total;
}

// 这里sizeof ar的值为8字节。
```

- marbles 是一个数组，ar 是一个指向 marbles 数组首元素的指针，利用 C 中数组和指针的特殊关系，可以用数组表示法来表示指针 ar。

### 保护数组中的数据

- 编写一个处理基本类型（如，int）的函数时，要选择是传递 int 类型的值还是传递指向 int 的指针。通常都是直接传递数值，只有程序需要在函数中改变该数值时，才会传递指针。对于数组别无选择，必须传递指针，因为这样做效率高。
- 一般而言，如果编写的函数需要修改数组，在声明数组形参时则不使用 const；如果编写的函数不用修改数组，那么在声明数组形参时最好使用 const。
