# 数组与指针

## 数组

- 数组由数据类型相同的一系列元素组成。

```c
// 一些数组声明
int main(void) {
    float candy[365]    // 内含365个float类型的元素的数组
    char code[12]       // 内含12个char类型元素的数组 
    int states[50]      // 内含50个int类型元素的数组
}
```

使用数组下标(索引)表示数组中的各元素，数组编号从0开始。

## 初始化数组

```c
int main(void) {
    int powers[8] = {1,2,4,6,8,16,32,64}    // 从ANSI C开始支持这种初始化
}

// 推荐使用符号常量来表示数组大小,方便于管理
#define NUM 8

int main(void) {
    int powers[NUM] = {1,2,4,6,8,16,32,64}
}
```

- 使用const声明只读数组，不能把新值写入数组。

```c
#define MONTH 12

int main(void) {
    const int days[MONTH] = {31,28,31,30,31,30,31,31,30,31,30,31}
}
```

- 当我们使用数组前必须先初始化它。与普通变量类似，在使用数组元素之前，必须先给它们赋初值。编译器使用的值是内存相应位置上的现有值。[运行示例](http)。**注意存储类别的区别，这里使用的是自动存储类别。不同的存储类别有不同的属性，不能把此知识点推广到其他存储类别上。使用其他的存储类别时，如果在声明时未初始化，编译器会自动把它们的值设置为0。**

- 如果不初始化数组，数组元素和未初始化的普通变量一样，其中存储的都是垃圾值；但是，如果部分初始化数组，剩余的元素就会被初始化为0。

```c
#include<stdio.h>
#define NUM 8

int main(void) {
    int powers[NUM] = {1,2,4,6};
    int i;

    for(i = 0,i < NUM,i++) {
        printf("%d",powers[i]);
    } 

    return 0;
}

// 输出结果
1,2,4,6,0,0,0,0
```

- 如果初始化列表项多于数组元素的个数，编译报错

```c
#define NUM 8
int main(void) {
    int powers[NUM] = {1,2,3,4,5,6,7,8,9,10};
}
```

- 省略方括号中的数字，让编译器自动匹配数组大小和初始化列表中的项数

```c
int main(void) {
    int powers[] = {1,2,3,4,5,6,7,8,9,10};
}
```

- 指定初始化器

```c
int arr[6] = {[5] = 212,[1] = 20,21,22} 

// 初始化内部结果
int arr[6] = {0,20,21,22,0,212}
```

> 指定初始化器的两个重要特性：
> 1.如果指定初始化器后面有更多的值，那么后面这些值将被用于初始化指定元素后面的元素。
> 2.如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。

- 给数组元素赋值
  - 声明数组后，可以借助数组下标（或索引）给数组元素复制。
  - **C不允许把数组作为一个单元赋给另一个数组，除初始化以外也不允许使用花括号列表的形式赋值。**

- 数组边界
  - 使用数组时，要防止数组下标超出边界。也就是说，必须确保下标是有效的值。使用数组时，要防止数组下标超出边界。也就是说，必须确保下标是有效的值
  - 使用越界的数组下标会导致程序改变其他变量的值。不同的编译器运行该程序的结果可能不同，有些会导致程序异常中止。

- 指定数组的大小

  -
